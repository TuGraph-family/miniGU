# Development Guide for gql-parser

Currently, the project aims to port ISO GQL's [ANTLR grammar](https://github.com/opengql/grammar/blob/main/GQL.g4) to Rust using [winnow](https://github.com/winnow-rs/winnow), a parser combinator framework in Rust. This documentation provides a development guide for the project.

## Parser Combinator
Formally, a parser combinator is a higher-order function that accepts several parsers as input and returns a new parser as its output, according to [Wikipedia](https://en.wikipedia.org/wiki/Parser_combinator). This allows us to implement a parser in a structural and declarative way, while keeping good debugability and observability. If you are not familiar with parser combinators, you can have a look at the [tutorial of winnow](https://docs.rs/winnow/latest/winnow/_tutorial/chapter_0/index.html), which gives useful guidance for beginners.

## Project Structure
There are three basic modules in the project: AST definitions, lexer implementations and parser implementations.
### AST definitions
This module defines high-level abstract syntax trees (AST) for GQL language. For example, we have `Program` for the `<GQL-program>` syntax rule (Section 6 in the GQL standard), which is the entry rule of the parser:

https://github.com/TuGraph-family/miniGU/blob/b4e3c8617cc61f226a217404ac2f7d421211dad0/minigu/parser/src/ast/program.rs#L7-L11

The `#[apply(base)]` attribute is an alias for common derivable traits (`Debug`, `Clone`, etc) and optionally, `Serialize` and `Deserialize` from `serde`. In principle it should be applied for all AST structs/enums. The fields `activity` and `session_close` correspond to the components `<program activity>` and `<session close command>` in the syntax rule. To provide accurate location tracking, we wrap most AST nodes in `Spanned`, a container of a value and its span. The `OptSpanned<T>` in the example is an alias of `Option<Spanned<T>>`.

Currently, AST definitions are grouped as Rust submodules by their general classes in the GQL standard. For example, `Program` and `ProgramActivity` are defined in `src/ast/program.rs` since they are introduced in Section 6 `<GQL-program>` in the standard, and `Literal` and `UnsignedInteger` are defined in `src/ast/lexical.rs` since they are introduced in Section 21 `Lexical elements`. The section number is also marked in the ANTLR grammar, such as `// 20.2 <value expression primary>`.

Unlike parse trees generated by ANTLR, the AST here should only contain meaningful elements. Syntactical indicators or separators, e.g., `MATCH`, `(` and `,`, should be discarded after parsing. 

### Lexer
The workflow of gql-parser is divided into two passes: tokenizing and parsing. The tokenizing pass transforms the string input into a list of tokens. And this is achieved by regex-based lexer powered by [Logos](https://github.com/maciejhirsz/logos). The lexer code is in `src/lexer.rs`.

The lexer is defined by regexes like `0x(_?[0-9a-fA-F])+`, and Logos compiles them into deterministic state machines. You can refer to the current lexer definition (`TokenKind`) if you need to add new lexer rules.

### Parser
Parsing is implemented by parser combinators in winnow. The parser code is in `src/parser/impls/*.rs`, and it follows the same layout as AST definitions. For example, parsers related to transaction management are defined in `src/parser/impls/transaction.rs`, and the corresponding AST definitions are located in `src/ast/transaction.rs`.

You can see the following section **Porting ANTLR grammar** or refer to existing code for details about how to write new parsers.  

## Porting ANTLR grammar
We give several examples below to help you understand the mapping between GQL's ANTLR grammar and parser combinators in Rust.

### Example 1: regularIdentifier
In GQL's ANTLR grammar, `regularIdentifier` is defined as
```antlr
regularIdentifier
    : REGULAR_IDENTIFIER
    | nonReservedWords
    ;
```

The corresponding parser in Rust is shown as follows.

https://github.com/TuGraph-family/miniGU/blob/b4e3c8617cc61f226a217404ac2f7d421211dad0/minigu/parser/src/parser/impls/lexical.rs#L14-L22

`any` is a parser in winnow that accepts arbitrary tokens. And we apply `verify_map` on it to check the kind of the token. If the token is a `RegularIdentifier` or a non-reserved word (see GQL standard for more details), the parser succeeds and returns the result `Ident`, which is further wrapped as `Spanned<Ident>` by `.spanned()`.

## Example 2: startTransactionCommand
In GQL's ANTLR grammar, `startTransactionCommand` is defined as
```antlr
startTransactionCommand
    : START TRANSACTION transactionCharacteristics?
    ;

transactionCharacteristics
    : transactionMode (COMMA transactionMode)*
    ;
```

The corresponding parser in Rust is shown as follows.

https://github.com/TuGraph-family/miniGU/blob/b4e3c8617cc61f226a217404ac2f7d421211dad0/minigu/parser/src/parser/impls/transaction.rs#L10-L20

`(TokenKind::Start, TokenKind::Transaction)` is the sequential combination of two parsers that accept `START` and `TRANSACTION`. `preceded` executes two parsers and discards the result from the first one. `separated(0.., transaction_access_mode, TokenKind::Comma)` recognizes exactly the same input as ANTLR rule `transactionCharacteristics`.

It should be noted that we are not making a one-to-one mapping between ANTLR grammar rules and Rust parsers. You can inline some parsers (like `transactionCharacteristics`) in its caller or define extra parsers if you need. The only requirement is that the recognized language conforms to the GQL standard.  

# Example 3: edgeTypePatternDirected
In GQL's ANTLR grammar, `edgeTypePatternDirected` is defined as
```antlr
edgeTypePatternDirected
    : edgeTypePatternPointingRight
    | edgeTypePatternPointingLeft
    ;

edgeTypePatternPointingRight
    : sourceNodeTypeReference arcTypePointingRight destinationNodeTypeReference
    ;

edgeTypePatternPointingLeft
    : destinationNodeTypeReference arcTypePointingLeft sourceNodeTypeReference
    ;
```

The corresponding parser in Rust is shown as follows.

https://github.com/TuGraph-family/miniGU/blob/b4e3c8617cc61f226a217404ac2f7d421211dad0/minigu/parser/src/parser/impls/type_element.rs#L351-L375

This rule has two alternatives: `edgeTypePatternPointingRight` (e.g., `(a)-[:KNOWS]->(b)`) and `edgeTypePatternPointingLeft` (e.g., `(a)<-[:KNOWS]-(b)`). How do we make a choice between them? We can first parse the node type reference (`(a)`) and then peek one token ahead to determine the next step. By using `peek(any)`, we get the lookahead token without forwarding the input stream. And we use `dispatch!` (a helper macro that wraps the pattern matching statement) on the token to choose the next parser. If the token is `MinusLeftBracket` (`-[`), we invoke the parser `arc_type_pointing_right`. And if the token is `LeftArrowBracket` (`<-[`), we invoke the parser `arc_type_pointing_left`. Finally we invoke `node_type_reference` to parse the node type reference in the tail.

It's all up to you to decide the number of lookahead tokens. You can use `peek((any, any))`, `peek((any, any, any))` or something like `peek((any, opt(any)))` to peek more tokens ahead. If you are not clear about the prefix of rule alternatives, you can use `alt` to choose between them. This combinator tries each alternative and returns the result from the first successful one. But in general `dispatch` is recommended since it avoids backtracking and provides better performance.

## Error Handling
Since we focus on the support of GQL features, we follow a simplified approach to handle parse errors. That is, we represent all parser errors by `UnexpectedError`, which means you can just use `fail` with no context attached in your implementation for now.

We will provide more detailed and user-friendly errors in the future.

## Testing
There are two types of tests in gql-parser: unit tests and integration tests. And to provide readable test results and reduce the work of writing test results manually, we use snapshot testing based on [Insta](https://insta.rs). You can consider it as an extension to the basic `assert_*!` macros, where test outputs are serialized into YAML or other formats to improve readability. Also, it provides CLI tools to generate and validate expected test outputs.

### Prepare `Insta`
Execute the following command to install Insta CLI tools:
```bash
$ cargo install cargo-insta
```

If you are using VSCode or its variants, it is recommended to install [Insta extension](https://marketplace.visualstudio.com/items?itemName=mitsuhiko.insta).

### Unit tests
Unit testing verifies on the functionality of a single parser. You should write them inside `tests` modules in source files. And the test function should follow the naming `test_<parser_name>`. 

You don't need to fill in the expected test output yourself. For example, the code below shows a unit test for parser `boolean_literal`.

https://github.com/TuGraph-family/miniGU/blob/b4e3c8617cc61f226a217404ac2f7d421211dad0/minigu/parser/src/parser/impls/lexical.rs#L237-L241

Execute the following command (assume your workspace directory is the project root) to run all tests in gql-parser:
```bash
$ cargo insta test -p gql-parser --features std,serde
```

If you run some test for the first time, you will see the following output:
```bash
info: 1 snapshot to review
use `cargo insta review` to review snapshots
```

Run `cargo insta review` as the instruction says, and you can check whether the generated test result is correct. If it is correct, press key 'a' to accept the result. The result then becomes the expected test output, saved in `src/parser/impls/snaoshots/*.snap`. If you have Insta VSCode extension installed, you can press F12 on `assert_yaml_snapshot!` to check the expected output.

Next time you run `cargo test -p gql-parser --features std,serde`, the test function should succeed.

### Integration tests
Integration testing verifies the functionality of public APIs (specifically, `parse_gql` in gql-parser). For integration tests, we inherit the test cases in the project root (`../../resources/gql`) and use them in `tests/parser_test.rs`. The test results are located in `tests/snapshots`. Like what we have done in unit tests, we use Insta to generate and validate test results. Run `cargo insta test -p gql-parser --features std,serde` to generate test results and run `cargo insta review` to review them.