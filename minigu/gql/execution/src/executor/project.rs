use itertools::Itertools;
use minigu_common::data_chunk::DataChunk;

use super::utils::gen_try;
use super::{Executor, IntoExecutor};
use crate::evaluator::BoxedEvaluator;

/// Project executor builder
///
/// The Project operator calculates the projection expression for each row of input data and generates new columns.
/// This is the core implementation of the RETURN clause.
///
/// #Field description
/// - `child`: child executor, providing input data
/// - `evaluators`: a list of projection expression evaluators, each corresponding to a column of the output
#[derive(Debug)]
pub struct ProjectBuilder<E> {
    child: E,
    evaluators: Vec<BoxedEvaluator>,
}

impl<E> ProjectBuilder<E> {
    pub fn new(child: E, evaluators: Vec<BoxedEvaluator>) -> Self {
        Self { child, evaluators }
    }
}

impl<E> IntoExecutor for ProjectBuilder<E>
where
    E: Executor,
{
    type IntoExecutor = impl Executor;

    /// Convert ProjectBuilder to executor
    ///
    /// # Experiment 2: Project operator implementation
    ///
    /// ## Task description
    /// Implement the core logic of the Project executor and calculate the projection expression for each row of input data.
    ///
    /// ## Execution process
    /// 1. Traverse each DataChunk generated by the sub-executor
    /// 2. For each chunk, use evaluators to calculate new columns
    /// 3. Create a DataChunk containing the new column
    /// 4. Keep the original filter (if any)
    /// 5. yield new chunk
    ///
    /// ## Key API
    /// - `evaluator.evaluate(&chunk)` -> `Result<DataValue>`
    /// - `DataValue::into_array()` -> `ArrayRef`
    /// - `DataChunk::new(columns: Vec<ArrayRef>)`
    /// - `chunk.filter()` -> `Option<&BooleanArray>`
    /// - `chunk.with_filter(filter)` -> `DataChunk`
    fn into_executor(self) -> Self::IntoExecutor {
        gen move {
            let ProjectBuilder { child, evaluators } = self;
            for chunk in child.into_iter() {
                let chunk = gen_try!(chunk);

                // ============================================================
                // LAB2 TODO: Implement Project projection logic
                // ============================================================
                //
                // Steps:
                // 1. Use evaluators to calculate new columns
                // - Loop through evaluators, calling evaluate(&chunk) on each one
                // - Convert the result to an ArrayRef
                //
                // 2. Create a new DataChunk
                // - use DataChunk::new(columns)
                //
                // 3. Keep the original filter
                // - Check if chunk.filter() is Some
                // - If so, call new_chunk.with_filter(filter.clone())
                //
                // 4. yield Ok(new_chunk)
                //
                // Please implement below:
                // ============================================================

                // YOUR CODE HERE
                let _ = evaluators; // Remove this line, just to get rid of the unused variable warning
                let _ = chunk; // Remove this line, just to get rid of the unused variable warning
                todo!("LAB2: Implement Project projection logic")

                // ============================================================
                // END LAB2 TODO
                // ============================================================
            }
        }
        .into_executor()
    }
}

#[cfg(test)]
mod tests {
    use minigu_common::data_chunk;

    use super::*;
    use crate::evaluator::Evaluator;
    use crate::evaluator::column_ref::ColumnRef;
    use crate::evaluator::constant::Constant;

    #[test]
    fn test_project() {
        let chunk = data_chunk!(
            { true, false, true },
            (Int32, [1, 2, 3]),
            (Utf8, ["a", "b", "c"])
        );
        let e1 = ColumnRef::new(0)
            .mul(ColumnRef::new(0))
            .add(Constant::new(3i32.into()));
        let e2 = ColumnRef::new(1);
        let e3 = ColumnRef::new(0).add(Constant::new(1i32.into()));
        let chunk: DataChunk = [Ok(chunk)]
            .into_executor()
            .project(vec![Box::new(e1), Box::new(e2), Box::new(e3)])
            .into_iter()
            .try_collect()
            .unwrap();
        let expected = data_chunk!((Int32, [4, 12]), (Utf8, ["a", "c"]), (Int32, [2, 4]));
        assert_eq!(chunk, expected);
    }
}
