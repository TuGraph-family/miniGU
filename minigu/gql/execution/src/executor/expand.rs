use std::sync::Arc;

use arrow::array::{Array, AsArray, ListArray};
use arrow::buffer::OffsetBuffer;
use arrow::datatypes::Field;
use itertools::Itertools;
use minigu_common::types::{LabelId, VertexIdArray};

use super::utils::gen_try;
use super::{Executor, IntoExecutor};
use crate::source::ExpandSource;

/// Expand executor builder
///
/// The Expand operator starts from the input vertex and expands along the edges to neighboring vertices.
/// This is the core implementation of graph traversal queries such as `MATCH (a)-[e]->(b)`).
///
/// #Field description
/// - `child`: child executor, providing input vertices
/// - `input_column_index`: The column index where the input vertex ID is located
/// - `edge_labels`: edge label filter conditions (DNF form: outer OR, inner AND)
/// - `target_vertex_labels`: Label filter conditions for target vertices
/// - `source`: graph data source, providing neighbor query capabilities
///
/// #Input and output
/// - Input: DataChunk containing vertex IDs
/// - Output: original column + edge information column + neighbor vertex column
#[derive(Debug)]
pub struct ExpandBuilder<E, S> {
    child: E,
    input_column_index: usize,
    edge_labels: Option<Vec<Vec<LabelId>>>,
    target_vertex_labels: Option<Vec<Vec<LabelId>>>,
    source: S,
}

impl<E, S> ExpandBuilder<E, S> {
    pub fn new(
        child: E,
        input_column_index: usize,
        edge_labels: Option<Vec<Vec<LabelId>>>,
        target_vertex_labels: Option<Vec<Vec<LabelId>>>,
        source: S,
    ) -> Self {
        Self {
            child,
            input_column_index,
            edge_labels,
            target_vertex_labels,
            source,
        }
    }
}

impl<E, S> IntoExecutor for ExpandBuilder<E, S>
where
    E: Executor,
    S: ExpandSource,
{
    type IntoExecutor = impl Executor;

    /// Convert ExpandBuilder to executor
    ///
    /// # Experiment 2: Expand operator implementation
    ///
    /// ## Task description
    /// Implement the core logic of the Expand executor, expand the input vertices along the edges to obtain neighbor vertices.
    ///
    /// ## Execution process
    /// 1. Traverse each DataChunk generated by the sub-executor
    /// 2. compact() chunk removes filtered rows
    /// 3. Extract the vertex ID column from the chunk
    /// 4. For each vertex, call source.expand_from_vertex() to obtain neighbors
    /// 5. Append neighbor information (edge ​​ID, target vertex ID) to chunk
    /// 6. yield expanded chunk
    ///
    /// ## Key API
    /// - `chunk.compact()`: remove filter lines
    /// - `chunk.slice(offset, length)`: get subset
    /// - `chunk.columns().get(index)`: Get columns
    /// - `column.as_primitive()`: Convert to vertex ID array
    /// - `source.expand_from_vertex(vid, edge_labels, target_labels)`: Get neighbors
    /// - `ListArray::try_new(...)`: Create a list array
    /// - `chunk.append_columns(columns)`: Append columns
    fn into_executor(self) -> Self::IntoExecutor {
        gen move {
            let ExpandBuilder {
                child,
                input_column_index,
                edge_labels,
                target_vertex_labels,
                source,
            } = self;
            for chunk in child.into_iter() {
                let mut chunk = gen_try!(chunk);

                // ============================================================
                // LAB2 TODO: Implement Expand graph expansion logic    
                // 请在下方实现:
                // ============================================================

                // YOUR CODE HERE
                let _ = input_column_index; // Remove this line
                let _ = edge_labels; // Remove this line
                let _ = target_vertex_labels; // Remove this line
                let _ = source; // remove this line
                let _ = chunk; // remove this line
                todo!("LAB2: Implement Expand graph expansion logic")

                // ============================================================
                // END LAB2 TODO
                // ============================================================
            }
        }
        .into_executor()
    }
}

#[cfg(test)]
mod tests {
    use arrow::array::{ArrayRef, ListBuilder, StringBuilder, UInt64Builder, create_array};
    use arrow::datatypes::DataType;
    use minigu_common::data_chunk;
    use minigu_common::data_chunk::DataChunk;

    use super::*;
    use crate::source::mock::{MockExpandSource, MockExpandSourceBuilder};

    fn build_test_source() -> MockExpandSource {
        MockExpandSourceBuilder::new(2)
            .add_vertex(1.try_into().unwrap())
            .add_vertex(3.try_into().unwrap())
            .add_vertex(5.try_into().unwrap())
            .add_edge(1.try_into().unwrap(), 2.try_into().unwrap(), "e1".into())
            .add_edge(1.try_into().unwrap(), 3.try_into().unwrap(), "e2".into())
            .add_edge(1.try_into().unwrap(), 4.try_into().unwrap(), "e3".into())
            .add_edge(3.try_into().unwrap(), 123.try_into().unwrap(), "e4".into())
            .build()
    }

    #[test]
    fn test_expand() {
        let chunk = data_chunk!(
            { true, false, true, true, true},
            (UInt64, [1, 2, 3, 4, 5]),
            (Utf8, ["abc", "def", "ghi", "jkl", "mno"])
        );
        let chunk: DataChunk = [Ok(chunk)]
            .into_executor()
            .expand(0, None, None, build_test_source())
            .into_iter()
            .try_collect()
            .unwrap();
        let neighbors_field = Field::new_list_field(DataType::UInt64, false);
        let mut neighbors_builder =
            ListBuilder::new(UInt64Builder::new()).with_field(Arc::new(neighbors_field));
        neighbors_builder.append_value([Some(2), Some(3)]);
        neighbors_builder.append_value([Some(4)]);
        neighbors_builder.append_value([Some(123)]);
        let neighbors = Arc::new(neighbors_builder.finish()) as ArrayRef;

        let properties_field = Field::new_list_field(DataType::Utf8, false);
        let mut properties_builder =
            ListBuilder::new(StringBuilder::new()).with_field(Arc::new(properties_field));
        properties_builder.append_value([Some("e1"), Some("e2")]);
        properties_builder.append_value([Some("e3")]);
        properties_builder.append_value([Some("e4")]);
        let properties = Arc::new(properties_builder.finish()) as ArrayRef;

        let expected = DataChunk::new(vec![
            create_array!(UInt64, [1, 1, 3]) as _,
            create_array!(Utf8, ["abc", "abc", "ghi"]) as _,
            neighbors as _,
            properties as _,
        ]);
        assert_eq!(chunk, expected);
    }
}
