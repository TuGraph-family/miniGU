use lalrpop_util::ParseError;

use crate::ast::*;
use crate::error::UserError;
use crate::lexer::*;
use crate::span::Span;
use crate::imports::*;

grammar<'a>(input: &'a str);

extern {
    type Location = usize;
    type Error = UserError;

    enum Token<'a> {
        "regular identifier" => Token { kind: TokenKind::RegularIdentifier(<&'a str>), .. },
        "unsigned decimal integer" => Token { kind: TokenKind::UnsignedDecimalInteger(<&'a str>), .. },
        "unsigned octal integer" => Token { kind: TokenKind::UnsignedOctalInteger(<&'a str>), .. },
        "unsigned hex integer" => Token { kind: TokenKind::UnsignedHexInteger(<&'a str>), .. },
        "unsigned binary integer" => Token { kind: TokenKind::UnsignedBinaryInteger(<&'a str>), .. },
        "double quoted" => Token { kind: TokenKind::DoubleQuoted(<Quoted<'a>>), .. },
        "single quoted" => Token { kind: TokenKind::SingleQuoted(<Quoted<'a>>), .. },
        "accent quoted" => Token { kind: TokenKind::AccentQuoted(<Quoted<'a>>), .. },
        "general parameter reference" => Token { kind: TokenKind::GeneralParameterReference(<ParameterName<'a>>), .. },
        "substituted parameter reference" => Token { kind: TokenKind::SubstitutedParameterReference(<ParameterName<'a>>), .. },
        
        "]->" => Token { kind: TokenKind::BracketRightArrow, .. },
        "]~>" => Token { kind: TokenKind::BracketTildeRightArrow, .. },
        "||" => Token { kind: TokenKind::Concatenation, .. },
        "::" => Token { kind: TokenKind::DoubleColon, .. },
        ".." => Token { kind: TokenKind::DoublePeriod, .. },
        ">=" => Token { kind: TokenKind::GreaterThanOrEquals, .. },
        "<-" => Token { kind: TokenKind::LeftArrow, .. },
        "<~" => Token { kind: TokenKind::LeftArrowTilde, .. },
        "<-[" => Token { kind: TokenKind::LeftArrowBracket, .. },
        "<~[" => Token { kind: TokenKind::LeftArrowTildeBracket, .. },
        "<->" => Token { kind: TokenKind::LeftMinusRight, .. },
        "<-/" => Token { kind: TokenKind::LeftMinusSlash, .. },
        "<~/" => Token { kind: TokenKind::LeftTildeSlash, .. },
        "<=" => Token { kind: TokenKind::LessThanOrEquals, .. },
        "-[" => Token { kind: TokenKind::MinusLeftBracket, .. },
        "-/" => Token { kind: TokenKind::MinusSlash, .. },
        "<>" => Token { kind: TokenKind::NotEquals, .. },
        "->" => Token { kind: TokenKind::RightArrow, .. },
        "]-" => Token { kind: TokenKind::RightBracketMinus, .. },
        "]~" => Token { kind: TokenKind::RightBracketTilde, .. },
        "=>" => Token { kind: TokenKind::RightDoubleArrow, .. },
        "/-" => Token { kind: TokenKind::SlashMinus, .. },
        "/->" => Token { kind: TokenKind::SlashMinusRight, .. },
        "/~" => Token { kind: TokenKind::SlashTilde, .. },
        "/~>" => Token { kind: TokenKind::SlashTildeRight, .. },
        "~[" => Token { kind: TokenKind::TildeLeftBracket, .. },
        "~>" => Token { kind: TokenKind::TildeRightArrow, .. },
        "~/" => Token { kind: TokenKind::TildeSlash, .. },
        "&" => Token { kind: TokenKind::Ampersand, .. },
        "*" => Token { kind: TokenKind::Asterisk, .. },
        ":" => Token { kind: TokenKind::Colon, .. },
        "," => Token { kind: TokenKind::Comma, .. },
        "=" => Token { kind: TokenKind::Equals, .. },
        "!" => Token { kind: TokenKind::Exclamation, .. },
        ">" => Token { kind: TokenKind::RightAngleBracket, .. },
        "{" => Token { kind: TokenKind::LeftBrace, .. },
        "[" => Token { kind: TokenKind::LeftBracket, .. },
        "(" => Token { kind: TokenKind::LeftParen, .. },
        "<" => Token { kind: TokenKind::LeftAngleBracket, .. },
        "-" => Token { kind: TokenKind::Minus, .. },
        "%" => Token { kind: TokenKind::Percent, .. },
        "." => Token { kind: TokenKind::Period, .. },
        "+" => Token { kind: TokenKind::Plus, .. },
        "?" => Token { kind: TokenKind::QuestionMark, .. },
        "}" => Token { kind: TokenKind::RightBrace, .. },
        "]" => Token { kind: TokenKind::RightBracket, .. },
        ")" => Token { kind: TokenKind::RightParen, .. },
        "/" => Token { kind: TokenKind::Solidus, .. },
        "~" => Token { kind: TokenKind::Tilde, .. },
        "|" => Token { kind: TokenKind::VerticalBar, .. },

        "ABS" => Token { kind: TokenKind::Abs, .. },
        "ACOS" => Token { kind: TokenKind::Acos, .. },
        "ALL" => Token { kind: TokenKind::All, .. },
        "ALL_DIFFERENT" => Token { kind: TokenKind::AllDifferent, .. },
        "AND" => Token { kind: TokenKind::And, .. },
        "ANY" => Token { kind: TokenKind::Any, .. },
        "ARRAY" => Token { kind: TokenKind::Array, .. },
        "AS" => Token { kind: TokenKind::As, .. },
        "ASC" => Token { kind: TokenKind::Asc, .. },
        "ASCENDING" => Token { kind: TokenKind::Ascending, .. },
        "ASIN" => Token { kind: TokenKind::Asin, .. },
        "AT" => Token { kind: TokenKind::At, .. },
        "ATAN" => Token { kind: TokenKind::Atan, .. },
        "AVG" => Token { kind: TokenKind::Avg, .. },
        "BIG" => Token { kind: TokenKind::Big, .. },
        "BIGINT" => Token { kind: TokenKind::Bigint, .. },
        "BINARY" => Token { kind: TokenKind::Binary, .. },
        "BOOL" => Token { kind: TokenKind::Bool, .. },
        "BOOLEAN" => Token { kind: TokenKind::Boolean, .. },
        "BOTH" => Token { kind: TokenKind::Both, .. },
        "BTRIM" => Token { kind: TokenKind::Btrim, .. },
        "BY" => Token { kind: TokenKind::By, .. },
        "BYTE_LENGTH" => Token { kind: TokenKind::ByteLength, .. },
        "BYTES" => Token { kind: TokenKind::Bytes, .. },
        "CALL" => Token { kind: TokenKind::Call, .. },
        "CARDINALITY" => Token { kind: TokenKind::Cardinality, .. },
        "CASE" => Token { kind: TokenKind::Case, .. },
        "CAST" => Token { kind: TokenKind::Cast, .. },
        "CEIL" => Token { kind: TokenKind::Ceil, .. },
        "CEILING" => Token { kind: TokenKind::Ceiling, .. },
        "CHAR" => Token { kind: TokenKind::Char, .. },
        "CHAR_LENGTH" => Token { kind: TokenKind::CharLength, .. },
        "CHARACTER_LENGTH" => Token { kind: TokenKind::CharacterLength, .. },
        "CHARACTERISTICS" => Token { kind: TokenKind::Characteristics, .. },
        "CLOSE" => Token { kind: TokenKind::Close, .. },
        "COALESCE" => Token { kind: TokenKind::Coalesce, .. },
        "COLLECT_LIST" => Token { kind: TokenKind::CollectList, .. },
        "COMMIT" => Token { kind: TokenKind::Commit, .. },
        "COPY" => Token { kind: TokenKind::Copy, .. },
        "COS" => Token { kind: TokenKind::Cos, .. },
        "COSH" => Token { kind: TokenKind::Cosh, .. },
        "COT" => Token { kind: TokenKind::Cot, .. },
        "COUNT" => Token { kind: TokenKind::Count, .. },
        "CREATE" => Token { kind: TokenKind::Create, .. },
        "CURRENT_DATE" => Token { kind: TokenKind::CurrentDate, .. },
        "CURRENT_GRAPH" => Token { kind: TokenKind::CurrentGraph, .. },
        "CURRENT_PROPERTY_GRAPH" => Token { kind: TokenKind::CurrentPropertyGraph, .. },
        "CURRENT_SCHEMA" => Token { kind: TokenKind::CurrentSchema, .. },
        "CURRENT_TIME" => Token { kind: TokenKind::CurrentTime, .. },
        "CURRENT_TIMESTAMP" => Token { kind: TokenKind::CurrentTimestamp, .. },
        "DATE" => Token { kind: TokenKind::Date, .. },
        "DATETIME" => Token { kind: TokenKind::Datetime, .. },
        "DAY" => Token { kind: TokenKind::Day, .. },
        "DEC" => Token { kind: TokenKind::Dec, .. },
        "DECIMAL" => Token { kind: TokenKind::Decimal, .. },
        "DEGREES" => Token { kind: TokenKind::Degrees, .. },
        "DELETE" => Token { kind: TokenKind::Delete, .. },
        "DESC" => Token { kind: TokenKind::Desc, .. },
        "DESCENDING" => Token { kind: TokenKind::Descending, .. },
        "DETACH" => Token { kind: TokenKind::Detach, .. },
        "DISTINCT" => Token { kind: TokenKind::Distinct, .. },
        "DOUBLE" => Token { kind: TokenKind::Double, .. },
        "DROP" => Token { kind: TokenKind::Drop, .. },
        "DURATION" => Token { kind: TokenKind::Duration, .. },
        "DURATION_BETWEEN" => Token { kind: TokenKind::DurationBetween, .. },
        "ELEMENT_ID" => Token { kind: TokenKind::ElementId, .. },
        "ELSE" => Token { kind: TokenKind::Else, .. },
        "END" => Token { kind: TokenKind::End, .. },
        "EXCEPT" => Token { kind: TokenKind::Except, .. },
        "EXISTS" => Token { kind: TokenKind::Exists, .. },
        "EXP" => Token { kind: TokenKind::Exp, .. },
        "FALSE" => Token { kind: TokenKind::False, .. },
        "FILTER" => Token { kind: TokenKind::Filter, .. },
        "FINISH" => Token { kind: TokenKind::Finish, .. },
        "FLOAT" => Token { kind: TokenKind::Float, .. },
        "FLOAT16" => Token { kind: TokenKind::Float16, .. },
        "FLOAT32" => Token { kind: TokenKind::Float32, .. },
        "FLOAT64" => Token { kind: TokenKind::Float64, .. },
        "FLOAT128" => Token { kind: TokenKind::Float128, .. },
        "FLOAT256" => Token { kind: TokenKind::Float256, .. },
        "FLOOR" => Token { kind: TokenKind::Floor, .. },
        "FOR" => Token { kind: TokenKind::For, .. },
        "FROM" => Token { kind: TokenKind::From, .. },
        "GROUP" => Token { kind: TokenKind::Group, .. },
        "HAVING" => Token { kind: TokenKind::Having, .. },
        "HOME_GRAPH" => Token { kind: TokenKind::HomeGraph, .. },
        "HOME_PROPERTY_GRAPH" => Token { kind: TokenKind::HomePropertyGraph, .. },
        "HOME_SCHEMA" => Token { kind: TokenKind::HomeSchema, .. },
        "HOUR" => Token { kind: TokenKind::Hour, .. },
        "IF" => Token { kind: TokenKind::If, .. },
        "IMPLIES" => Token { kind: TokenKind::Implies, .. },
        "IN" => Token { kind: TokenKind::In, .. },
        "INSERT" => Token { kind: TokenKind::Insert, .. },
        "INT" => Token { kind: TokenKind::Int, .. },
        "INTEGER" => Token { kind: TokenKind::Integer, .. },
        "INT8" => Token { kind: TokenKind::Int8, .. },
        "INTEGER8" => Token { kind: TokenKind::Integer8, .. },
        "INT16" => Token { kind: TokenKind::Int16, .. },
        "INTEGER16" => Token { kind: TokenKind::Integer16, .. },
        "INT32" => Token { kind: TokenKind::Int32, .. },
        "INTERVAL" => Token { kind: TokenKind::Interval, .. },
        "IS" => Token { kind: TokenKind::Is, .. },
        "INTEGER32" => Token { kind: TokenKind::Integer32, .. },
        "INT64" => Token { kind: TokenKind::Int64, .. },
        "INTEGER64" => Token { kind: TokenKind::Integer64, .. },
        "INT128" => Token { kind: TokenKind::Int128, .. },
        "INTEGER128" => Token { kind: TokenKind::Integer128, .. },
        "INT256" => Token { kind: TokenKind::Int256, .. },
        "INTEGER256" => Token { kind: TokenKind::Integer256, .. },
        "INTERSECT" => Token { kind: TokenKind::Intersect, .. },
        "LEADING" => Token { kind: TokenKind::Leading, .. },
        "LEFT" => Token { kind: TokenKind::Left, .. },
        "LET" => Token { kind: TokenKind::Let, .. },
        "LIKE" => Token { kind: TokenKind::Like, .. },
        "LIMIT" => Token { kind: TokenKind::Limit, .. },
        "LIST" => Token { kind: TokenKind::List, .. },
        "LN" => Token { kind: TokenKind::Ln, .. },
        "LOCAL" => Token { kind: TokenKind::Local, .. },
        "LOCAL_DATETIME" => Token { kind: TokenKind::LocalDatetime, .. },
        "LOCAL_TIME" => Token { kind: TokenKind::LocalTime, .. },
        "LOCAL_TIMESTAMP" => Token { kind: TokenKind::LocalTimestamp, .. },
        "LOG" => Token { kind: TokenKind::Log, .. },
        "LOG10" => Token { kind: TokenKind::Log10, .. },
        "LOWER" => Token { kind: TokenKind::Lower, .. },
        "LTRIM" => Token { kind: TokenKind::Ltrim, .. },
        "MATCH" => Token { kind: TokenKind::Match, .. },
        "MAX" => Token { kind: TokenKind::Max, .. },
        "MIN" => Token { kind: TokenKind::Min, .. },
        "MINUTE" => Token { kind: TokenKind::Minute, .. },
        "MOD" => Token { kind: TokenKind::Mod, .. },
        "MONTH" => Token { kind: TokenKind::Month, .. },
        "NEXT" => Token { kind: TokenKind::Next, .. },
        "NODETACH" => Token { kind: TokenKind::Nodetach, .. },
        "NORMALIZE" => Token { kind: TokenKind::Normalize, .. },
        "NOT" => Token { kind: TokenKind::Not, .. },
        "NOTHING" => Token { kind: TokenKind::Nothing, .. },
        "NULL" => Token { kind: TokenKind::Null, .. },
        "NULLS" => Token { kind: TokenKind::Nulls, .. },
        "NULLIF" => Token { kind: TokenKind::Nullif, .. },
        "OCTET_LENGTH" => Token { kind: TokenKind::OctetLength, .. },
        "OF" => Token { kind: TokenKind::Of, .. },
        "OFFSET" => Token { kind: TokenKind::Offset, .. },
        "OPTIONAL" => Token { kind: TokenKind::Optional, .. },
        "OR" => Token { kind: TokenKind::Or, .. },
        "ORDER" => Token { kind: TokenKind::Order, .. },
        "OTHERWISE" => Token { kind: TokenKind::Otherwise, .. },
        "PARAMETER" => Token { kind: TokenKind::Parameter, .. },
        "PARAMETERS" => Token { kind: TokenKind::Parameters, .. },
        "PATH" => Token { kind: TokenKind::Path, .. },
        "PATH_LENGTH" => Token { kind: TokenKind::PathLength, .. },
        "PATHS" => Token { kind: TokenKind::Paths, .. },
        "PERCENTILE_CONT" => Token { kind: TokenKind::PercentileCont, .. },
        "PERCENTILE_DISC" => Token { kind: TokenKind::PercentileDisc, .. },
        "POWER" => Token { kind: TokenKind::Power, .. },
        "PRECISION" => Token { kind: TokenKind::Precision, .. },
        "PROPERTY_EXISTS" => Token { kind: TokenKind::PropertyExists, .. },
        "RADIANS" => Token { kind: TokenKind::Radians, .. },
        "REAL" => Token { kind: TokenKind::Real, .. },
        "RECORD" => Token { kind: TokenKind::Record, .. },
        "REMOVE" => Token { kind: TokenKind::Remove, .. },
        "REPLACE" => Token { kind: TokenKind::Replace, .. },
        "RESET" => Token { kind: TokenKind::Reset, .. },
        "RETURN" => Token { kind: TokenKind::Return, .. },
        "RIGHT" => Token { kind: TokenKind::Right, .. },
        "ROLLBACK" => Token { kind: TokenKind::Rollback, .. },
        "RTRIM" => Token { kind: TokenKind::Rtrim, .. },
        "SAME" => Token { kind: TokenKind::Same, .. },
        "SCHEMA" => Token { kind: TokenKind::Schema, .. },
        "SECOND" => Token { kind: TokenKind::Second, .. },
        "SELECT" => Token { kind: TokenKind::Select, .. },
        "SESSION" => Token { kind: TokenKind::Session, .. },
        "SESSION_USER" => Token { kind: TokenKind::SessionUser, .. },
        "SET" => Token { kind: TokenKind::Set, .. },
        "SIGNED" => Token { kind: TokenKind::Signed, .. },
        "SIN" => Token { kind: TokenKind::Sin, .. },
        "SINH" => Token { kind: TokenKind::Sinh, .. },
        "SIZE" => Token { kind: TokenKind::Size, .. },
        "SKIP" => Token { kind: TokenKind::Skip, .. },
        "SMALL" => Token { kind: TokenKind::Small, .. },
        "SMALLINT" => Token { kind: TokenKind::Smallint, .. },
        "SQRT" => Token { kind: TokenKind::Sqrt, .. },
        "START" => Token { kind: TokenKind::Start, .. },
        "STDDEV_POP" => Token { kind: TokenKind::StddevPop, .. },
        "STDDEV_SAMP" => Token { kind: TokenKind::StddevSamp, .. },
        "STRING" => Token { kind: TokenKind::String, .. },
        "SUM" => Token { kind: TokenKind::Sum, .. },
        "TAN" => Token { kind: TokenKind::Tan, .. },
        "TANH" => Token { kind: TokenKind::Tanh, .. },
        "THEN" => Token { kind: TokenKind::Then, .. },
        "TIME" => Token { kind: TokenKind::Time, .. },
        "TIMESTAMP" => Token { kind: TokenKind::Timestamp, .. },
        "TRAILING" => Token { kind: TokenKind::Trailing, .. },
        "TRIM" => Token { kind: TokenKind::Trim, .. },
        "TRUE" => Token { kind: TokenKind::True, .. },
        "TYPED" => Token { kind: TokenKind::Typed, .. },
        "UBIGINT" => Token { kind: TokenKind::Ubigint, .. },
        "UINT" => Token { kind: TokenKind::Uint, .. },
        "UINT8" => Token { kind: TokenKind::Uint8, .. },
        "UINT16" => Token { kind: TokenKind::Uint16, .. },
        "UINT32" => Token { kind: TokenKind::Uint32, .. },
        "UINT64" => Token { kind: TokenKind::Uint64, .. },
        "UINT128" => Token { kind: TokenKind::Uint128, .. },
        "UINT256" => Token { kind: TokenKind::Uint256, .. },
        "UNION" => Token { kind: TokenKind::Union, .. },
        "UNKNOWN" => Token { kind: TokenKind::Unknown, .. },
        "UNSIGNED" => Token { kind: TokenKind::Unsigned, .. },
        "UPPER" => Token { kind: TokenKind::Upper, .. },
        "USE" => Token { kind: TokenKind::Use, .. },
        "USMALLINT" => Token { kind: TokenKind::Usmallint, .. },
        "VALUE" => Token { kind: TokenKind::Value, .. },
        "VARBINARY" => Token { kind: TokenKind::Varbinary, .. },
        "VARCHAR" => Token { kind: TokenKind::Varchar, .. },
        "VARIABLE" => Token { kind: TokenKind::Variable, .. },
        "WHEN" => Token { kind: TokenKind::When, .. },
        "WHERE" => Token { kind: TokenKind::Where, .. },
        "WITH" => Token { kind: TokenKind::With, .. },
        "XOR" => Token { kind: TokenKind::Xor, .. },
        "YEAR" => Token { kind: TokenKind::Year, .. },
        "YIELD" => Token { kind: TokenKind::Yield, .. },
        "ZONED" => Token { kind: TokenKind::Zoned, .. },
        "ZONED_DATETIME" => Token { kind: TokenKind::ZonedDatetime, .. },
        "ZONED_TIME" => Token { kind: TokenKind::ZonedTime, .. },

        "ABSTRACT" => Token { kind: TokenKind::Abstract, .. },
        "AGGREGATE" => Token { kind: TokenKind::Aggregate, .. },
        "AGGREGATES" => Token { kind: TokenKind::Aggregates, .. },
        "ALTER" => Token { kind: TokenKind::Alter, .. },
        "CATALOG" => Token { kind: TokenKind::Catalog, .. },
        "CLEAR" => Token { kind: TokenKind::Clear, .. },
        "CLONE" => Token { kind: TokenKind::Clone, .. },
        "CONSTRAINT" => Token { kind: TokenKind::Constraint, .. },
        "CURRENT_ROLE" => Token { kind: TokenKind::CurrentRole, .. },
        "CURRENT_USER" => Token { kind: TokenKind::CurrentUser, .. },
        "DATA" => Token { kind: TokenKind::Data, .. },
        "DIRECTORY" => Token { kind: TokenKind::Directory, .. },
        "DRYRUN" => Token { kind: TokenKind::Dryrun, .. },
        "EXACT" => Token { kind: TokenKind::Exact, .. },
        "EXISTING" => Token { kind: TokenKind::Existing, .. },
        "FUNCTION" => Token { kind: TokenKind::Function, .. },
        "GQLSTATUS" => Token { kind: TokenKind::Gqlstatus, .. },
        "GRANT" => Token { kind: TokenKind::Grant, .. },
        "INSTANT" => Token { kind: TokenKind::Instant, .. },
        "INFINITY" => Token { kind: TokenKind::Infinity, .. },
        "NUMBER" => Token { kind: TokenKind::Number, .. },
        "NUMERIC" => Token { kind: TokenKind::Numeric, .. },
        "ON" => Token { kind: TokenKind::On, .. },
        "OPEN" => Token { kind: TokenKind::Open, .. },
        "PARTITION" => Token { kind: TokenKind::Partition, .. },
        "PROCEDURE" => Token { kind: TokenKind::Procedure, .. },
        "PRODUCT" => Token { kind: TokenKind::Product, .. },
        "PROJECT" => Token { kind: TokenKind::Project, .. },
        "QUERY" => Token { kind: TokenKind::Query, .. },
        "RECORDS" => Token { kind: TokenKind::Records, .. },
        "REFERENCE" => Token { kind: TokenKind::Reference, .. },
        "RENAME" => Token { kind: TokenKind::Rename, .. },
        "REVOKE" => Token { kind: TokenKind::Revoke, .. },
        "SUBSTRING" => Token { kind: TokenKind::Substring, .. },
        "SYSTEM_USER" => Token { kind: TokenKind::SystemUser, .. },
        "TEMPORAL" => Token { kind: TokenKind::Temporal, .. },
        "UNIQUE" => Token { kind: TokenKind::Unique, .. },
        "UNIT" => Token { kind: TokenKind::Unit, .. },
        "VALUES" => Token { kind: TokenKind::Values, .. },
        "WHITESPACE" => Token { kind: TokenKind::Whitespace, .. },

        "ACYCLIC" => Token { kind: TokenKind::Acyclic, slice: <&'a str> },
        "BINDING" => Token { kind: TokenKind::Binding, slice: <&'a str> },
        "BINDINGS" => Token { kind: TokenKind::Bindings, slice: <&'a str> },
        "CONNECTING" => Token { kind: TokenKind::Connecting, slice: <&'a str> },
        "DESTINATION" => Token { kind: TokenKind::Destination, slice: <&'a str> },
        "DIFFERENT" => Token { kind: TokenKind::Different, slice: <&'a str> },
        "DIRECTED" => Token { kind: TokenKind::Directed, slice: <&'a str> },
        "EDGE" => Token { kind: TokenKind::Edge, slice: <&'a str> },
        "EDGES" => Token { kind: TokenKind::Edges, slice: <&'a str> },
        "ELEMENT" => Token { kind: TokenKind::Element, slice: <&'a str> },
        "ELEMENTS" => Token { kind: TokenKind::Elements, slice: <&'a str> },
        "FIRST" => Token { kind: TokenKind::First, slice: <&'a str> },
        "GRAPH" => Token { kind: TokenKind::Graph, slice: <&'a str> },
        "GROUPS" => Token { kind: TokenKind::Groups, slice: <&'a str> },
        "KEEP" => Token { kind: TokenKind::Keep, slice: <&'a str> },
        "LABEL" => Token { kind: TokenKind::Label, slice: <&'a str> },
        "LABELED" => Token { kind: TokenKind::Labeled, slice: <&'a str> },
        "LABELS" => Token { kind: TokenKind::Labels, slice: <&'a str> },
        "LAST" => Token { kind: TokenKind::Last, slice: <&'a str> },
        "NFC" => Token { kind: TokenKind::Nfc, slice: <&'a str> },
        "NFD" => Token { kind: TokenKind::Nfd, slice: <&'a str> },
        "NFKC" => Token { kind: TokenKind::Nfkc, slice: <&'a str> },
        "NFKD" => Token { kind: TokenKind::Nfkd, slice: <&'a str> },
        "NO" => Token { kind: TokenKind::No, slice: <&'a str> },
        "NODE" => Token { kind: TokenKind::Node, slice: <&'a str> },
        "NORMALIZED" => Token { kind: TokenKind::Normalized, slice: <&'a str> },
        "ONLY" => Token { kind: TokenKind::Only, slice: <&'a str> },
        "ORDINALITY" => Token { kind: TokenKind::Ordinality, slice: <&'a str> },
        "PROPERTY" => Token { kind: TokenKind::Property, slice: <&'a str> },
        "READ" => Token { kind: TokenKind::Read, slice: <&'a str> },
        "RELATIONSHIP" => Token { kind: TokenKind::Relationship, slice: <&'a str> },
        "RELATIONSHIPS" => Token { kind: TokenKind::Relationships, slice: <&'a str> },
        "REPEATABLE" => Token { kind: TokenKind::Repeatable, slice: <&'a str> },
        "SHORTEST" => Token { kind: TokenKind::Shortest, slice: <&'a str> },
        "SIMPLE" => Token { kind: TokenKind::Simple, slice: <&'a str> },
        "SOURCE" => Token { kind: TokenKind::Source, slice: <&'a str> },
        "TABLE" => Token { kind: TokenKind::Table, slice: <&'a str> },
        "TEMP" => Token { kind: TokenKind::Temp, slice: <&'a str> },
        "TO" => Token { kind: TokenKind::To, slice: <&'a str> },
        "TRAIL" => Token { kind: TokenKind::Trail, slice: <&'a str> },
        "TRANSACTION" => Token { kind: TokenKind::Transaction, slice: <&'a str> },
        "TYPE" => Token { kind: TokenKind::Type, slice: <&'a str> },
        "UNDIRECTED" => Token { kind: TokenKind::Undirected, slice: <&'a str> },
        "VERTEX" => Token { kind: TokenKind::Vertex, slice: <&'a str> },
        "WALK" => Token { kind: TokenKind::Walk, slice: <&'a str> },
        "WITHOUT" => Token { kind: TokenKind::Without, slice: <&'a str> },
        "WRITE" => Token { kind: TokenKind::Write, slice: <&'a str> },
        "ZONE" => Token { kind: TokenKind::Zone, slice: <&'a str> },
    }
}

// 6 <GQL-program>
// This is the entry point of the GQL parser.
pub GqlProgram: Program<'a> = {
    SessionCloseCommand => Program { activity: None, session_close: true },

}

EndTransactionCommand: EndTransaction = {
    "ROLLBACK" => EndTransaction::Rollback,
    "COMMIT" => EndTransaction::Commit,
}

// 7.3 <session close command>
SessionCloseCommand = "SESSION" "CLOSE";

// gqlProgram
//     : programActivity sessionCloseCommand? EOF
//     | sessionCloseCommand EOF
//     ;

// 11.1 <graph expression>
pub GraphExpression: GraphExpr<'a> = {
    ObjectNameOrBindingVariable => GraphExpr::Object(<>),
    CurrentGraph => GraphExpr::Current,
    GraphReference => GraphExpr::Ref(<>),
    // objectExpressionPrimary
}

CurrentGraph = { "CURRENT_PROPERTY_GRAPH", "CURRENT_GRAPH" };

// 11.2 <binding table expression>
// TODO: Add binding table expression.

// 11.3 <object expression primary>
// TODO: Add object expression primary.

// 12.1 <linear catalog-modifying statement>
LinearCatalogModifyingStatement = SimpleCatalogModifyingStatement+;

SimpleCatalogModifyingStatement = { PrimitiveCatalogModifyingStatement, CallCatalogModifyingProcedureStatement };

PrimitiveCatalogModifyingStatement: CatalogModifyingStatement<'a> = {
    CreateSchemaStatement => CatalogModifyingStatement::CreateSchema(<>),
    DropSchemaStatement => CatalogModifyingStatement::DropSchema(<>),
    CreateGraphStatement => CatalogModifyingStatement::CreateGraph(<>),
    DropGraphStatement => CatalogModifyingStatement::DropGraph(<>),
    CreateGraphTypeStatement => CatalogModifyingStatement::CreateGraphType(<>),
    DropGraphTypeStatement => CatalogModifyingStatement::DropGraphType(<>),
}

// 12.2 <insert schema statement>
CreateSchemaStatement: CreateSchemaStatement<'a> = {
    "CREATE" "SCHEMA" <if_not_exists: ("IF" "NOT" "EXISTS")?> <path: CatalogSchemaParentAndName> => {
        CreateSchemaStatement { if_not_exists: if_not_exists.is_some(), path }
    }
}

// 12.3 <drop schema statement>
DropSchemaStatement: DropSchemaStatement<'a> = {
    "DROP" "SCHEMA" <if_exists: ("IF" "EXISTS")?> <path: CatalogSchemaParentAndName> => {
        DropSchemaStatement { if_exists: if_exists.is_some(), path }
    }
}

// 12.4 <insert graph statement>
CreateGraphStatement: CreateGraphStatement<'a> = {
    "CREATE" <kind: CreateGraphStatementKind> <path: CatalogGraphParentAndName> <graph_type: OpenOrOfGraphType> <source: GraphSource?> => {
        CreateGraphStatement { kind, path, graph_type, source }
    } 
}

CreateGraphStatementKind: CreateGraphOrGraphTypeStatementKind = {
    "PROPERTY"? "GRAPH" => CreateGraphOrGraphTypeStatementKind::Create,
    "PROPERTY"? "GRAPH" "IF" "NOT" "EXISTS" => CreateGraphOrGraphTypeStatementKind::CreateIfNotExists,
    "OR" "REPLACE" "PROPERTY"? "GRAPH" => CreateGraphOrGraphTypeStatementKind::CreateOrReplace,
}

OpenOrOfGraphType: OfGraphType<'a> = {
    OpenGraphType => OfGraphType::Any,
    OfGraphType,
}

OpenGraphType = {
    Typed? "ANY" ("PROPERTY"? "GRAPH")?
}

// TODO: Add nested graph type specification.
OfGraphType: OfGraphType<'a> = {
    GraphTypeLikeGraph => OfGraphType::Like(<>),
    Typed? <GraphTypeReference> => OfGraphType::Ref(<>),
    // Typed? ("PROPERTY"? "GRAPH")? NestedGraphTypeSpecification,
}

GraphTypeLikeGraph = "LIKE" <GraphExpression>;

GraphSource = "AS" "COPY" "OF" <GraphExpression>;

// 12.5 <drop graph statement>
DropGraphStatement: DropGraphStatement<'a> = {
    "DROP" "PROPERTY"? "GRAPH" <if_exists: ("IF" "EXISTS")?> <path: CatalogGraphParentAndName> => {
        DropGraphStatement { if_exists: if_exists.is_some(), path }
    }
}

// 12.6 <graph type statement>
CreateGraphTypeStatement: CreateGraphTypeStatement<'a> = {
    "CREATE" <kind: CreateGraphTypeStatementKind> <path: CatalogGraphTypeParentAndName> <source: GraphTypeSource> => {
        CreateGraphTypeStatement { kind, path, source }
    }
}

CreateGraphTypeStatementKind: CreateGraphOrGraphTypeStatementKind = {
    "PROPERTY"? "GRAPH" "TYPE" => CreateGraphOrGraphTypeStatementKind::Create,
    "PROPERTY"? "GRAPH" "TYPE" "IF" "NOT" "EXISTS" => CreateGraphOrGraphTypeStatementKind::CreateIfNotExists,
    "OR" "REPLACE" "PROPERTY"? "GRAPH" "TYPE" => CreateGraphOrGraphTypeStatementKind::CreateOrReplace,
}

GraphTypeSource: GraphTypeSource<'a> = {
    "AS"? <CopyOfGraphType> => GraphTypeSource::Copy(<>),
    GraphTypeLikeGraph => GraphTypeSource::Like(<>),
    // "AS"? NestedGraphTypeSpecification => GraphTypeSource::Nested(<>),
}

CopyOfGraphType = "COPY" "OF" <GraphTypeReference>;

// 12.7 <drop graph statement>
DropGraphTypeStatement: DropGraphTypeStatement<'a> = {
    "DROP" "PROPERTY"? "GRAPH" "TYPE" <if_exists: ("IF" "EXISTS")?> <path: CatalogGraphTypeParentAndName> => {
        DropGraphTypeStatement { if_exists: if_exists.is_some(), path }
    }
}

// 12.8 <call catalog-modifying statement>
CallCatalogModifyingProcedureStatement: CatalogModifyingStatement<'a> = {
    CallProcedureStatement => CatalogModifyingStatement::Call(<>),
}

// 15.1 <call procedure statement> and <procedure call>
CallProcedureStatement: CallProcedureStatement<'a> = {
    <optional: "OPTIONAL"?> "CALL" <procedure: ProcedureCall> => {
        CallProcedureStatement { procedure, optional: optional.is_some() }
    }
}

// TODO: Add inline procedure call.
ProcedureCall: ProcedureCall<'a> = {
    NamedProcedureCall => ProcedureCall::Named(<>),
    // InlineProcedureCall,
}

// 15.3 <named procedure call>
NamedProcedureCall: NamedProcedureCall<'a> = {
    <name: ProcedureReference> "(" <args: ListHelper<ValueExpression, ",">?> ")" <yield_clause: YieldClause?> => {
        NamedProcedureCall { name, args: args.unwrap_or_default(), yield_clause }
    }
}

// 16.1 <at schema clasue>
AtSchemaClause = "AT" SchemaReference;

// 16.2 <use graph clause>
UseGraphClause = "USE" GraphExpression;

// 16.7 <path pattern expression>
IsOrColon = { "IS", ":" }

// 16.8 <label expression>
pub LabelExpression: LabelExpr<'a> = {
    #[precedence(level = "0")]
    LabelName => LabelExpr::Label(<>),
    "%" => LabelExpr::Wildcard,
    "(" <LabelExpressionReset> ")",

    #[precedence(level = "1")]
    "!" <LabelExpression> => LabelExpr::Negation(Box::new(<>)),

    #[precedence(level = "2")]
    #[assoc(side = "left")]
    <l: LabelExpression> "&" <r: LabelExpression> => LabelExpr::Conjunction(Box::new(l), Box::new(r)),

    #[precedence(level = "3")]
    #[assoc(side = "left")]
    <l: LabelExpression> "|" <r: LabelExpression> => LabelExpr::Disjunction(Box::new(l), Box::new(r)),
}

// Add this rule to handle parenthesized label expressions due to LALRPOP's issue.
// See https://github.com/lalrpop/lalrpop/issues/596 for more details.
LabelExpressionReset = LabelExpression; 

pub IsLabelExpression = IsOrColon <LabelExpression>;

pub ElementVariableDeclaration: ElementVariableDeclaration<'a> = {
    <temp: "TEMP"?> <variable: RegularIdentifier> => {
        ElementVariableDeclaration {
            variable,
            temp: temp.is_some(),
        }
    }
}

// 16.14 <yield clause>
pub YieldClause: Yield<'a> = {
    "YIELD" <ListHelper<YieldItem, ",">> => Yield(<>)
}

YieldItem: YieldItem<'a> = {
    <name: FieldName> <alias: ("AS" <BindingVariable>)?> => YieldItem { name, alias }
}

// 17.1 <schema reference> and <catalog schema parent name>
// The following rules are rewritten to resolve shift-reduce conflicts.
pub SchemaReference: SchemaRef<'a> = {
    ReferenceParameterSpecification => SchemaRef::Parameter(<>),
    PredefinedSchemaReference => SchemaRef::Predefined(<>),
    AbsolutePathHelper => SchemaRef::Path(<>),
    RelativePathHelper => SchemaRef::Path(<>),
    RootPathHelper => SchemaRef::Path(<>)
}

PredefinedSchemaReference: PredefinedSchemaRef = {
    "HOME_SCHEMA" => PredefinedSchemaRef::Home,
    "CURRENT_SCHEMA" => PredefinedSchemaRef::Current,
    "." => PredefinedSchemaRef::Current,
}

RootPathHelper: Vec<SchemaPathComponent<'a>> = {
    "/" => vec![SchemaPathComponent::Root]
}

AbsolutePathHelper: Vec<SchemaPathComponent<'a>> = {
    "/" <path: SimpleObjectPath> => {
        let mut components = Vec::with_capacity(1 + path.len());
        components.push(SchemaPathComponent::Root);
        components.extend(path);
        components
    }
}

RelativePathHelper: Vec<SchemaPathComponent<'a>> = {
    ".." <head: ("/" "..")*> "/" <path: SimpleObjectPath> => {
        let mut components = Vec::with_capacity(1 + head.len() + path.len());
        components.push(SchemaPathComponent::Parent);
        components.extend(head.into_iter().map(|_| SchemaPathComponent::Parent));
        components.extend(path);
        components
    }
}

// Path that ends with an object name. 
SimpleObjectPath: Vec<SchemaPathComponent<'a>> = {
    <head: ObjectName> <tail: ("/" <ObjectName>)*> => {
        let mut path = Vec::with_capacity(1 + tail.len());
        path.push(SchemaPathComponent::Name(head));
        path.extend(tail.into_iter().map(|n| SchemaPathComponent::Name(n)));
        path
    }
}

CatalogSchemaParentAndName = AbsolutePathHelper;

// 17.2 <graph reference> and <catalog graph parent and name>
pub GraphReference: GraphRef<'a> = {
    DelimitedGraphName => GraphRef::Name(<>),
    ReferenceParameterSpecification => GraphRef::Parameter(<>),
    CatalogObjectReference => GraphRef::Ref(<>),
    HomeGraph => GraphRef::Home,
}

CatalogGraphParentAndName = CatalogObjectReferenceOptional;

// 17.3 <graph type reference> and <catalog graph type parent and name>
GraphTypeReference: GraphTypeRef<'a> = {
    CatalogGraphTypeParentAndName => GraphTypeRef::Ref(<>),
    ReferenceParameterSpecification => GraphTypeRef::Parameter(<>),
}

CatalogGraphTypeParentAndName = CatalogObjectReferenceOptional;

// 17.5 <procedure reference> and <catalog procedure parent and name>
ProcedureReference: ProcedureRef<'a> = {
    CatalogProcedureParentAndName => ProcedureRef::Ref(<>),
    ReferenceParameterSpecification => ProcedureRef::Parameter(<>),
}

CatalogProcedureParentAndName = CatalogObjectReferenceOptional;

// 17.6 <catalog object parent reference>
// This part is rewritten to resolve shift-reduce conflicts:
// CatalogObjectReferenceOptional <- CatalogObjectParentReference? ObjectName
// CatalogObjectReference <- CatalogObjectParentReference ObjectName
// TODO: Refactor this part to make it cleaner.
pub CatalogObjectReference: ObjectRef<'a> = {
    <schema: ReferenceParameterSpecification> "/" <objects: ListHelper<ObjectName, ".">> => {
        let schema = Some(SchemaRef::Parameter(schema));
        ObjectRef { schema, objects }
    },
    <schema: PredefinedSchemaReference> "/" <objects: ListHelper<ObjectName, ".">> => {
        let schema = Some(SchemaRef::Predefined(schema));
        ObjectRef { schema, objects }
    },
    CatalogObjectReferenceHelper<AbsolutePathHelper>,
    CatalogObjectReferenceHelper<RelativePathHelper>,
    <first: ObjectName> <remaining: ("." <ObjectName>)+> => {
        let mut objects = Vec::with_capacity(1 + remaining.len());
        objects.push(first);
        objects.extend(remaining);
        ObjectRef { schema: None, objects }
    },
}

pub CatalogObjectReferenceOptional: ObjectRef<'a> = {
    CatalogObjectReference,
    <object: ObjectName> => {
        ObjectRef { schema: None, objects: vec![object] }
    }
}

CatalogObjectReferenceHelper<P>: ObjectRef<'a> = {
    <mut schema_and_first_object: P> <remaining: ("." <ObjectName>)*> => {
        let first = schema_and_first_object.pop().unwrap().into_name().unwrap();
        let schema = Some(SchemaRef::Path(schema_and_first_object));
        let mut objects = Vec::with_capacity(1 + remaining.len());
        objects.push(first);
        objects.extend(remaining);
        ObjectRef { schema, objects }
    }
}

HomeGraph = { "HOME_PROPERTY_GRAPH", "HOME_GRAPH" };

// 17.7 <reference parameter specification>
ReferenceParameterSpecification = SubstitutedParameterReference;

// 18.1 <nested graph type specification>
// NestedGraphTypeSpecification = "LEFT_BRACE" <GraphTypeSpecificationBody> "RIGHT_BRACE";

// GraphTypeSpecificationBody = ListHelper<ElementTypeSpecification, ",">;

// ElementTypeSpecification = {
//     NodeTypeSpecification,
//     EdgeTypeSpecification
// }

// 18.2 <node type specification>
// nodeTypeSpecification
//     : nodeTypePattern
//     | nodeTypePhrase
//     ;

NodeTypePattern = {
    (NodeSynonym "TYPE"? ObjectName)? "(" LocalNodeTypeAlias?
}

// nodeTypePattern
//     : (nodeSynonym TYPE? nodeTypeName)? LEFT_PAREN localNodeTypeAlias? nodeTypeFiller? RIGHT_PAREN
//     ;

// nodeTypePhrase
//     : nodeSynonym TYPE? nodeTypePhraseFiller (AS localNodeTypeAlias)?
//     ;

// nodeTypePhraseFiller
//     : nodeTypeName nodeTypeFiller?
//     | nodeTypeFiller
//     ;

NodeTypeFiller = {
    NodeTypeKeyLabelSet NodeTypeImpliedContent?,
    // NodeTypeImpliedContent
}

LocalNodeTypeAlias = RegularIdentifier;

NodeTypeImpliedContent = {
    NodeTypeLabelSet,
    // NodeTypePropertyTypes,
    // NodeTypeLabelSet NodeTypePropertyTypes
}

NodeTypeKeyLabelSet = <LabelSetPhrase?> "IMPLIES";

NodeTypeLabelSet = LabelSetPhrase;

NodeTypePropertyTypes = PropertyTypesSpecification;

// 18.3 <edge type specification>

// edgeTypeSpecification
//     : edgeTypePattern
//     | edgeTypePhrase
//     ;

// edgeTypePattern
//     : (edgeKind? edgeSynonym TYPE? edgeTypeName)? (edgeTypePatternDirected | edgeTypePatternUndirected)
//     ;

// edgeTypePhrase
//     : edgeKind edgeSynonym TYPE? edgeTypePhraseFiller endpointPairPhrase
//     ;

// edgeTypePhraseFiller
//     : edgeTypeName edgeTypeFiller?
//     | edgeTypeFiller
//     ;

// edgeTypeFiller
//     : edgeTypeKeyLabelSet edgeTypeImpliedContent?
//     | edgeTypeImpliedContent
//     ;

// edgeTypeImpliedContent
//     : edgeTypeLabelSet
//     | edgeTypePropertyTypes
//     | edgeTypeLabelSet edgeTypePropertyTypes
//     ;

// edgeTypeKeyLabelSet
//     : labelSetPhrase? IMPLIES
//     ;

// edgeTypeLabelSet
//     : labelSetPhrase
//     ;

// edgeTypePropertyTypes
//     : propertyTypesSpecification
//     ;

// edgeTypePatternDirected
//     : edgeTypePatternPointingRight
//     | edgeTypePatternPointingLeft
//     ;

// edgeTypePatternPointingRight
//     : sourceNodeTypeReference arcTypePointingRight destinationNodeTypeReference
//     ;

// edgeTypePatternPointingLeft
//     : destinationNodeTypeReference arcTypePointingLeft sourceNodeTypeReference
//     ;

// edgeTypePatternUndirected
//     : sourceNodeTypeReference arcTypeUndirected destinationNodeTypeReference
//     ;

// arcTypePointingRight
//     : MINUS_LEFT_BRACKET edgeTypeFiller BRACKET_RIGHT_ARROW
//     ;

// arcTypePointingLeft
//     : LEFT_ARROW_BRACKET edgeTypeFiller RIGHT_BRACKET_MINUS
//     ;

// arcTypeUndirected
//     : TILDE_LEFT_BRACKET edgeTypeFiller RIGHT_BRACKET_TILDE
//     ;

// sourceNodeTypeReference
//     : LEFT_PAREN sourceNodeTypeAlias RIGHT_PAREN
//     | LEFT_PAREN nodeTypeFiller? RIGHT_PAREN
//     ;

// destinationNodeTypeReference
//     : LEFT_PAREN destinationNodeTypeAlias RIGHT_PAREN
//     | LEFT_PAREN nodeTypeFiller? RIGHT_PAREN
//     ;

// edgeKind
//     : DIRECTED
//     | UNDIRECTED
//     ;

// endpointPairPhrase
//     : CONNECTING endpointPair
//     ;

// endpointPair
//     : endpointPairDirected
//     | endpointPairUndirected
//     ;

// endpointPairDirected
//     : endpointPairPointingRight
//     | endpointPairPointingLeft
//     ;

// endpointPairPointingRight
//     : LEFT_PAREN sourceNodeTypeAlias connectorPointingRight destinationNodeTypeAlias RIGHT_PAREN
//     ;

// endpointPairPointingLeft
//     : LEFT_PAREN destinationNodeTypeAlias LEFT_ARROW sourceNodeTypeAlias RIGHT_PAREN
//     ;

// endpointPairUndirected
//     : LEFT_PAREN sourceNodeTypeAlias connectorUndirected destinationNodeTypeAlias RIGHT_PAREN
//     ;

// connectorPointingRight
//     : TO
//     | RIGHT_ARROW
//     ;

// connectorUndirected
//     : TO
//     | TILDE
//     ;

// sourceNodeTypeAlias
//     : regularIdentifier
//     ;

// destinationNodeTypeAlias
//     : regularIdentifier
//     ;

// 18.4 <label set phrase> and <label set specification>
LabelSetPhrase: LabelSet<'a> = {
    "LABEL" <LabelName> => LabelSet::Label(<>),
    "LABELS" <LabelSetSpecification> => LabelSet::Labels(<>),
    IsOrColon <LabelSetSpecification> => LabelSet::Labels(<>),
}

LabelSetSpecification = ListHelper<LabelName, "&">;

// 18.5 <property types specification>
PropertyTypesSpecification: Vec<FieldOrPropertyType<'a>> = {
    "{" <ListHelper<PropertyType, ",">?> "}" => <>.unwrap_or_default()
}

// 18.6 <property type>
PropertyType: FieldOrPropertyType<'a> = {
    <name: PropertyName> Typed? <value_type: PropertyValueType> => FieldOrPropertyType { name, value_type }
}

// 18.7 <property value type>
PropertyValueType = ValueType;

// 18.8 <binding table type>
BindingTableType = "BINDING"? "TABLE" <FieldTypesSpecification>;

// 18.9 <value type>
// TODO: Add dynamic union type.
// TODO: Add closed dynamic union type.
ValueType: ValueType<'a> = {
    PredefinedType,
    "PATH" <NotNull?> => ValueType { kind: ValueTypeKind::Path, not_null: <>.is_some() },
    <type_name: ListValueTypeName> <value_type: ("<" <ValueType> ">")?> <max_length: ("[" <MaxLength> "]")?> <not_null: NotNull?> => {
        ValueType { 
            kind: ValueTypeKind::List { 
                type_name,
                value_type: value_type.map(Box::new),
                max_length
            }, 
            not_null: not_null.is_some()
        }
    },
    <value_type: ValueType> <type_name: ListValueTypeName> <max_length: ("[" <MaxLength> "]")?> <not_null: NotNull?> => {
        ValueType { 
            kind: ValueTypeKind::List {
                type_name,
                value_type: Some(Box::new(value_type)),
                max_length
            },
            not_null: not_null.is_some()
        }
    },
    RecordType
}

Typed = { "::", "TYPED"}

// TODO: Add temporal type.
// TODO: Add reference value type.
PredefinedType = {
    BooleanType,
    CharacterStringType,
    ByteStringType,
    NumericType,
    ImmaterialValueType
}

BooleanType: ValueType<'a> = {
    "BOOL" <NotNull?> => ValueType { kind: ValueTypeKind::Bool, not_null: <>.is_some() },
    "BOOLEAN" <NotNull?> => ValueType { kind: ValueTypeKind::Bool, not_null: <>.is_some() },
}

CharacterStringType: ValueType<'a> = {
    "STRING" <min_max_length: MinMaxLength?> <not_null: NotNull?> => {
        let (min_length, max_length) = min_max_length.map(|(min, max)| (min, Some(max))).unwrap_or_default();
        ValueType { kind: ValueTypeKind::String { min_length, max_length }, not_null: not_null.is_some() }
    },
    "CHAR" <fixed_length: ("(" <FixedLength> ")")?> <not_null: NotNull?> => {
        ValueType { kind: ValueTypeKind::Char(fixed_length), not_null: not_null.is_some() }
    },
    "VARCHAR" <max_length: ("(" <MaxLength> ")")?> <not_null: NotNull?> => {
        ValueType { kind: ValueTypeKind::Varchar(max_length), not_null: not_null.is_some() }
    }
}

ByteStringType: ValueType<'a> = {
    "BYTES" <min_max_length: MinMaxLength?> <not_null: NotNull?> => {
        let (min_length, max_length) = min_max_length.map(|(min, max)| (min, Some(max))).unwrap_or_default();
        ValueType { kind: ValueTypeKind::Bytes { min_length, max_length }, not_null: not_null.is_some() }
    },
    "BINARY" <fixed_length: ("(" <FixedLength> ")")?> <not_null: NotNull?> => {
        ValueType { kind: ValueTypeKind::Binary(fixed_length), not_null: not_null.is_some() }
    },
    "VARBINARY" <max_length: ("(" <MaxLength> ")")?> <not_null: NotNull?> => {
        ValueType { kind: ValueTypeKind::Varbinary(max_length), not_null: not_null.is_some() }
    }
}

MinMaxLength: (Option<UnsignedInteger<'a>>, UnsignedInteger<'a>) = {
    "(" <min_length: MinLength> "," <max_length: MaxLength> ")" => (Some(min_length), max_length),
    "(" <max_length: MaxLength> ")" => (None, max_length)
}

NumericType = { ExactNumericType, ApproximateNumericType }

ExactNumericType = { BinaryExactNumericType, DecimalExactNumericType }

BinaryExactNumericType = { SignedBinaryExactNumericType, UnsignedBinaryExactNumericType }

SignedBinaryExactNumericType: ValueType<'a> = {
    "INT8" <not_null: NotNull?> => ValueType { kind: ValueTypeKind::SignedNumeric(NumericTypeKind::Int8), not_null: not_null.is_some() },
    "INT16" <not_null: NotNull?> => ValueType { kind: ValueTypeKind::SignedNumeric(NumericTypeKind::Int16), not_null: not_null.is_some() },
    "INT32" <not_null: NotNull?> => ValueType { kind: ValueTypeKind::SignedNumeric(NumericTypeKind::Int32), not_null: not_null.is_some() },
    "INT64" <not_null: NotNull?> => ValueType { kind: ValueTypeKind::SignedNumeric(NumericTypeKind::Int64), not_null: not_null.is_some() },
    "INT128" <not_null: NotNull?> => ValueType { kind: ValueTypeKind::SignedNumeric(NumericTypeKind::Int128), not_null: not_null.is_some() },
    "INT256" <not_null: NotNull?> => ValueType { kind: ValueTypeKind::SignedNumeric(NumericTypeKind::Int256), not_null: not_null.is_some() },
    "SMALLINT" <not_null: NotNull?> => ValueType { kind: ValueTypeKind::SignedNumeric(NumericTypeKind::Small), not_null: not_null.is_some() },
    "INT" <precision: ("(" <Precision> ")")?> <not_null: NotNull?> => ValueType { kind: ValueTypeKind::SignedNumeric(NumericTypeKind::Int(precision)), not_null: not_null.is_some() },
    "BIGINT" <not_null: NotNull?> => ValueType { kind: ValueTypeKind::SignedNumeric(NumericTypeKind::Big), not_null: not_null.is_some() },
    "SIGNED"? <VerboseBinaryExactNumericType> => ValueType { kind: ValueTypeKind::SignedNumeric(<>.0), not_null: <>.1 },
}

UnsignedBinaryExactNumericType: ValueType<'a> = {
    "UINT8" <not_null: NotNull?> => ValueType { kind: ValueTypeKind::UnsignedNumeric(NumericTypeKind::Int8), not_null: not_null.is_some() },
    "UINT16" <not_null: NotNull?> => ValueType { kind: ValueTypeKind::UnsignedNumeric(NumericTypeKind::Int16), not_null: not_null.is_some() },
    "UINT32" <not_null: NotNull?> => ValueType { kind: ValueTypeKind::UnsignedNumeric(NumericTypeKind::Int32), not_null: not_null.is_some() },
    "UINT64" <not_null: NotNull?> => ValueType { kind: ValueTypeKind::UnsignedNumeric(NumericTypeKind::Int64), not_null: not_null.is_some() },
    "UINT128" <not_null: NotNull?> => ValueType { kind: ValueTypeKind::UnsignedNumeric(NumericTypeKind::Int128), not_null: not_null.is_some() },
    "UINT256" <not_null: NotNull?> => ValueType { kind: ValueTypeKind::UnsignedNumeric(NumericTypeKind::Int256), not_null: not_null.is_some() },
    "USMALLINT" <not_null: NotNull?> => ValueType { kind: ValueTypeKind::UnsignedNumeric(NumericTypeKind::Small), not_null: not_null.is_some() },
    "UINT" <precision: ("(" <Precision> ")")?> <not_null: NotNull?> => ValueType { kind: ValueTypeKind::UnsignedNumeric(NumericTypeKind::Int(precision)), not_null: not_null.is_some() },
    "UBIGINT" <not_null: NotNull?> => ValueType { kind: ValueTypeKind::UnsignedNumeric(NumericTypeKind::Big), not_null: not_null.is_some() },
    "UNSIGNED" <VerboseBinaryExactNumericType> => ValueType { kind: ValueTypeKind::UnsignedNumeric(<>.0), not_null: <>.1 },
}

VerboseBinaryExactNumericType: (NumericTypeKind<'a>, bool) = {
    "INTEGER8" <NotNull?> => (NumericTypeKind::Int8, <>.is_some()),
    "INTEGER16" <NotNull?> => (NumericTypeKind::Int16, <>.is_some()),
    "INTEGER32" <NotNull?> => (NumericTypeKind::Int32, <>.is_some()),
    "INTEGER64" <NotNull?> => (NumericTypeKind::Int64, <>.is_some()),
    "INTEGER128" <NotNull?> => (NumericTypeKind::Int128, <>.is_some()),
    "INTEGER256" <NotNull?> => (NumericTypeKind::Int256, <>.is_some()),
    "SMALL" "INTEGER" <NotNull?> => (NumericTypeKind::Small, <>.is_some()),
    "INTEGER" <precision: ("(" <Precision> ")")?> <not_null: NotNull?> => (NumericTypeKind::Int(precision), not_null.is_some()),
    "BIG" "INTEGER" <NotNull?> => (NumericTypeKind::Big, <>.is_some()),
}

DecimalExactNumericType: ValueType<'a> = {
    DecimalOrDec <precision_scale_not_null: PrecisionScaleNotNull?> => {
        let (precision, scale, not_null) = precision_scale_not_null.map(|(a, b, c)| (Some(a), b, c)).unwrap_or_default();
        ValueType { kind: ValueTypeKind::Decimal { precision, scale }, not_null }
    }
}

DecimalOrDec = { "DECIMAL", "DEC" }

PrecisionScaleNotNull: (UnsignedInteger<'a>, Option<UnsignedInteger<'a>>, bool) = {
    "(" <precision: Precision> <scale: ("," <Scale>)?> ")" <not_null: NotNull?> => {
        (precision, scale, not_null.is_some())
    }
}

PrecisionScale: (UnsignedInteger<'a>, Option<UnsignedInteger<'a>>) = {
    "(" <precision: Precision> <scale: ("," <Scale>)?> ")" => {
        (precision, scale)
    }
}

Precision = UnsignedDecimalInteger;

Scale = UnsignedDecimalInteger;

ApproximateNumericType: ValueType<'a> = {
    "FLOAT16" <not_null: NotNull?> => ValueType { kind: ValueTypeKind::Float(FloatTypeKind::Float16), not_null: not_null.is_some() },
    "FLOAT32" <not_null: NotNull?> => ValueType { kind: ValueTypeKind::Float(FloatTypeKind::Float32), not_null: not_null.is_some() },
    "FLOAT64" <not_null: NotNull?> => ValueType { kind: ValueTypeKind::Float(FloatTypeKind::Float64), not_null: not_null.is_some() },
    "FLOAT128" <not_null: NotNull?> => ValueType { kind: ValueTypeKind::Float(FloatTypeKind::Float128), not_null: not_null.is_some() },
    "FLOAT256" <not_null: NotNull?> => ValueType { kind: ValueTypeKind::Float(FloatTypeKind::Float256), not_null: not_null.is_some() },
    "FLOAT" <precision_scale: PrecisionScale?> <not_null: NotNull?> => {
        let (precision, scale) = precision_scale.map(|(a, b)| (Some(a), b)).unwrap_or_default();
        ValueType { kind: ValueTypeKind::Float(FloatTypeKind::Float { precision, scale }), not_null: not_null.is_some() }
    },
    "REAL" <not_null: NotNull?> => ValueType { kind: ValueTypeKind::Float(FloatTypeKind::Real), not_null: not_null.is_some() },
    "DOUBLE" "PRECISION"? <not_null: NotNull?> => ValueType { kind: ValueTypeKind::Float(FloatTypeKind::Double), not_null: not_null.is_some() },
}

MinLength = UnsignedInteger;

MaxLength = UnsignedInteger;

FixedLength = UnsignedInteger;

RecordType: ValueType<'a> = {
    "ANY"? "RECORD" <NotNull?> => ValueType { kind: ValueTypeKind::Record(None), not_null: <>.is_some() },
    "RECORD"? <field_types: FieldTypesSpecification> <not_null: NotNull?> => ValueType { kind: ValueTypeKind::Record(Some(field_types)), not_null: not_null.is_some() },
}

FieldTypesSpecification: Vec<FieldOrPropertyType<'a>> = {
    "{" <ListHelper<FieldType, ",">?> "}" => <>.unwrap_or_default()
}

ImmaterialValueType: ValueType<'a> = {
    "NULL" => ValueType { kind: ValueTypeKind::Null, not_null: false },
    "NULL" NotNull => ValueType { kind: ValueTypeKind::Empty, not_null: true},
    "NOTHING" => ValueType { kind: ValueTypeKind::Empty, not_null: true},
}

NotNull = "NOT" "NULL";

// 18.10 <field type>
FieldType: FieldOrPropertyType<'a> = {
    <name: FieldName> Typed? <value_type: ValueType> => FieldOrPropertyType { name, value_type }
}

// 20.1 <value expression>
pub ValueExpression: Expr<'a> = {
    #[precedence(level = "0")]
    ValueExpressionPrimary,
    "+" <ValueExpression> => Expr::Unary { op: UnaryOp::Plus, child: Box::new(<>) },
    "-" <ValueExpression> => Expr::Unary { op: UnaryOp::Minus, child: Box::new(<>) },

    #[precedence(level = "1")]
    #[assoc(side = "left")]
    <l: ValueExpression> "*" <r: ValueExpression> => Expr::Binary { op: BinaryOp::Mul, left: Box::new(l), right: Box::new(r) },
    <l: ValueExpression> "/" <r: ValueExpression> => Expr::Binary { op: BinaryOp::Div, left: Box::new(l), right: Box::new(r) },

    #[precedence(level = "2")]
    #[assoc(side = "left")]
    <l: ValueExpression> "+" <r: ValueExpression> => Expr::Binary { op: BinaryOp::Add, left: Box::new(l), right: Box::new(r) },
    <l: ValueExpression> "-" <r: ValueExpression> => Expr::Binary { op: BinaryOp::Sub, left: Box::new(l), right: Box::new(r) },

    #[precedence(level = "3")]
    #[assoc(side = "left")]
    <l: ValueExpression> "||" <r: ValueExpression> => Expr::Binary { op: BinaryOp::Concat, left: Box::new(l), right: Box::new(r) },

    #[precedence(level = "4")]
    #[assoc(side = "left")]
    <l: ValueExpression> "<" <r: ValueExpression> => Expr::Binary { op: BinaryOp::Lt, left: Box::new(l), right: Box::new(r) },
    <l: ValueExpression> "<=" <r: ValueExpression> => Expr::Binary { op: BinaryOp::Le, left: Box::new(l), right: Box::new(r) },
    <l: ValueExpression> ">" <r: ValueExpression> => Expr::Binary { op: BinaryOp::Gt, left: Box::new(l), right: Box::new(r) },
    <l: ValueExpression> ">=" <r: ValueExpression> => Expr::Binary { op: BinaryOp::Ge, left: Box::new(l), right: Box::new(r) },
    <l: ValueExpression> "=" <r: ValueExpression> => Expr::Binary { op: BinaryOp::Eq, left: Box::new(l), right: Box::new(r) },
    <l: ValueExpression> "<>" <r: ValueExpression> => Expr::Binary { op: BinaryOp::Ne, left: Box::new(l), right: Box::new(r) },

    #[precedence(level = "5")]
    "NOT" <ValueExpression> => Expr::Unary { op: UnaryOp::Not, child: Box::new(<>) },

    #[precedence(level = "6")]
    #[assoc(side = "left")]
    <l: ValueExpression> "IS" <right: BooleanLiteral> => Expr::Is { left: Box::new(l), right },
    <l: ValueExpression> "IS" "NOT" <right: BooleanLiteral> => Expr::IsNot { left: Box::new(l), right },

    #[precedence(level = "7")]
    #[assoc(side = "left")]
    <l: ValueExpression> "AND" <r: ValueExpression> => Expr::Binary { op: BinaryOp::And, left: Box::new(l), right: Box::new(r) },

    #[precedence(level = "8")]
    #[assoc(side = "left")]
    <l: ValueExpression> "OR" <r: ValueExpression> => Expr::Binary { op: BinaryOp::Or, left: Box::new(l), right: Box::new(r) },
    <l: ValueExpression> "XOR" <r: ValueExpression> => Expr::Binary { op: BinaryOp::Xor, left: Box::new(l), right: Box::new(r) },

    #[precedence(level = "9")]
    "PROPERTY"? "GRAPH" <GraphExpression> => Expr::Graph(<>),
}

NodeReferenceValueExpression = ValueExpressionPrimary;

EdgeReferenceValueExpression = ValueExpressionPrimary;

RecordExpression = ValueExpressionPrimary;

AggregatingValueExpression = ValueExpression;

// 20.2 <value expression primary>
// TODO: Add case expression.
// TODO: Add cast specification.
// TODO: Add let expression.
ValueExpressionPrimary: Expr<'a> = {
    ParenthesizedValueExpression,
    UnsignedValueSpecification => Expr::Value(<>),
    PathValueConstructor => Expr::Path(Box::new(<>)),
    PropertyReference => Expr::Property(Box::new(<>)),
    BindingVariableReference => Expr::Variable(<>),
}

ParenthesizedValueExpression = "(" <ValueExpression> ")";

SetQuantifier: SetQuantifier = {
    "DISTINCT" => SetQuantifier::Distinct, 
    "ALL" => SetQuantifier::All
}

// 20.3 <value specification>
UnsignedValueSpecification: Value<'a> = {
    UnsignedLiteral => Value::Literal(<>),
    "SESSION_USER" => Value::SessionUser,
    DynamicParameterSpecification => Value::Parameter(<>),
}

// 20.4 <dynamic parameter specification>
DynamicParameterSpecification = GeneralParameterReference;

// 20.9 <aggregate function>

// 20.11 <property reference>
PropertyReference: PropertyRef<'a> = {
    <source: ValueExpressionPrimary> "." <name: PropertyName> => PropertyRef { source, name }
}

// 20.12 <binding variable reference>
BindingVariableReference = BindingVariable;

// 20.14 <path value constructor>
PathValueConstructor = "PATH" "[" <PathElementList> "]";

PathElementList: PathConstructor<'a> = {
    <start: NodeReferenceValueExpression> <steps: PathElementListStep*> => PathConstructor { start, steps }
}

PathElementListStep: PathStep<'a> = {
    "," <edge: EdgeReferenceValueExpression> "," <node: NodeReferenceValueExpression> => PathStep { edge, node }
}

// 20.17 <list value constructor>
pub ListValueConstructor: ListConstructor<'a> = {
    <type_name: ListValueTypeName?> "[" <values: ListHelper<ValueExpression, ",">?> "]" => ListConstructor { 
        type_name, values: values.unwrap_or_default() 
    }
}

ListValueTypeName: ListTypeName = {
    <group: "GROUP"?> <synonym: ListValueTypeNameSynonym> => ListTypeName { group: group.is_some(), synonym }
}

ListValueTypeNameSynonym: ListTypeNameSynonym = {
    "LIST" => ListTypeNameSynonym::List,
    "ARRAY" => ListTypeNameSynonym::Array,
}

// 20.18 <record constructor>
pub RecordConstructor: RecordConstructor<'a> = {
    "RECORD"? "{" <ListHelper<Field, ",">?> "}" => RecordConstructor(<>.unwrap_or_default())
}

Field: Field<'a> = <name: FieldName> <value: ValueExpression> => Field { name, value };

// 21.1 Names and variables
// Object: Directory, Schema, Graph, GraphType, NodeType, EdgeType, BindingTable, Procedure
ObjectName = Identifier;

ObjectNameOrBindingVariable = RegularIdentifier;

DelimitedGraphName = DelimitedIdentifier;

DelimitedBindingTableName = DelimitedIdentifier;

LabelName = Identifier;

PropertyName = Identifier;

FieldName = Identifier;

GraphPatternVariable = RegularIdentifier;

PathOrSubpathVariable = RegularIdentifier;

ElementVariable = BindingVariable;

PathVariable = BindingVariable;

SubpathVariable = RegularIdentifier;

BindingVariable = RegularIdentifier;

// 21.2 <literal>
// TODO: Add byte string literal
pub UnsignedLiteral: Literal<'a> = {
    UnsignedNumericLiteral => Literal::Numeric(<>),
    BooleanLiteral => Literal::Boolean(<>),
    CharStringLiteral => Literal::String(<>),
    TemporalLiteral => Literal::Temporal(<>),
    DurationLiteral => Literal::Duration(<>),
    ListValueConstructor => Literal::List(<>),
    RecordConstructor => Literal::Record(<>),
    "NULL" => Literal::Null,
}

BooleanLiteral: BooleanLiteral = {
    "TRUE" => BooleanLiteral::True,
    "FALSE" => BooleanLiteral::False,
    "UNKNOWN" => BooleanLiteral::Unknown,
}

CharStringLiteralHelper: Cow<'a, str> = {
    <start: @L> <quoted: "single quoted"> <end: @R> =>? {
        quoted.unescape().ok_or_else(|| ParseError::User { error: UserError::invalid_escape_sequence(start..end)})
    },
    <start: @L> <quoted: "double quoted"> <end: @R> =>? {
        quoted.unescape().ok_or_else(|| ParseError::User { error: UserError::invalid_escape_sequence(start..end)})
    }
}

CharStringLiteral: StringLiteral<'a> = {
    <literal: CharStringLiteralHelper> => StringLiteral { kind: StringLiteralKind::Char, literal }
}

// TODO: Add SQL-datetime literal.
TemporalLiteral: TemporalLiteral<'a> = {
    "DATE" <literal: CharStringLiteralHelper> => TemporalLiteral { kind: TemporalLiteralKind::Date, literal },
    "TIME" <literal: CharStringLiteralHelper> => TemporalLiteral { kind: TemporalLiteralKind::Time, literal },
    "DATETIME" <literal: CharStringLiteralHelper> => TemporalLiteral { kind: TemporalLiteralKind::Datetime, literal },
    "TIMESTAMP" <literal: CharStringLiteralHelper> => TemporalLiteral { kind: TemporalLiteralKind::Timestamp, literal },
}

// TODO: Add SQL-interval literal.
DurationLiteral: DurationLiteral<'a> = {
    "DURATION" <literal: CharStringLiteralHelper> => DurationLiteral { kind: DurationLiteralKind::Duration, literal },
}

// TODO: Add other literals.
UnsignedNumericLiteral: UnsignedNumericLiteral<'a> = {
    UnsignedInteger => UnsignedNumericLiteral::Integer(<>)
}

pub UnsignedInteger: UnsignedInteger<'a> = {
    UnsignedDecimalInteger,
    <integer: "unsigned octal integer"> => UnsignedInteger { kind: UnsignedIntegerKind::Octal, integer },
    <integer: "unsigned hex integer"> => UnsignedInteger { kind: UnsignedIntegerKind::Hex, integer },
    <integer: "unsigned binary integer"> => UnsignedInteger { kind: UnsignedIntegerKind::Binary, integer },
}

UnsignedDecimalInteger: UnsignedInteger<'a> = {
    <integer: "unsigned decimal integer"> => UnsignedInteger { kind: UnsignedIntegerKind::Decimal, integer }
}

// 21.3 <token>, <separator>, and <identifier>
pub Identifier = { RegularIdentifier, DelimitedIdentifier }

DelimitedIdentifier: Ident<'a> = {
    <start: @L> <quoted: "double quoted"> <end: @R> =>? {
        let span = Span { start, end };
        let name = quoted.unescape().ok_or_else(|| ParseError::User { error: UserError::invalid_escape_sequence(span)})?;
        Ok(Ident { name, span }) 
    },
    <start: @L> <quoted: "accent quoted"> <end: @R> =>? {
        let span = Span { start, end };
        let name = quoted.unescape().ok_or_else(|| ParseError::User { error: UserError::invalid_escape_sequence(span)})?;
        Ok(Ident { name, span })
    },
}

// TODO: Non-reserved words here will cause shift-reduce conflicts in later rules. 
// Add them back if conflicts can be resolved.
RegularIdentifier: Ident<'a> = {
    <start: @L> <name: "regular identifier"> <end: @R> => Ident { name: name.into(), span: Span { start, end } },
    // <start: @L> <name: NonReservedWord> <end: @R> => Ident { name: name.into(), span: Span { start, end } }
}

// NonReservedWord = {
//     "ACYCLIC",
//     "BINDING",
//     "BINDINGS",
//     "CONNECTING",
//     "DESTINATION",
//     "DIFFERENT",
//     "DIRECTED",
//     "EDGE",
//     "EDGES",
//     "ELEMENT",
//     "ELEMENTS",
//     "FIRST",
//     "GRAPH",
//     "GROUPS",
//     "KEEP",
//     "LABEL",
//     "LABELED",
//     "LABELS",
//     "LAST",
//     "NFC",
//     "NFD",
//     "NFKC",
//     "NFKD",
//     "NO",
//     "NODE",
//     "NORMALIZED",
//     "ONLY",
//     "ORDINALITY",
//     "PROPERTY",
//     "READ",
//     "RELATIONSHIP",
//     "RELATIONSHIPS",
//     "REPEATABLE",
//     "SHORTEST",
//     "SIMPLE",
//     "SOURCE",
//     "TABLE",
//     "TEMP",
//     "TO",
//     "TRAIL",
//     "TRANSACTION",
//     "TYPE",
//     "UNDIRECTED",
//     "VERTEX",
//     "WALK",
//     "WITHOUT",
//     "WRITE",
//     "ZONE",
// }

GeneralParameterReference: Ident<'a> = {
    <start: @L> <name: "general parameter reference"> <end: @R> =>? {
        let span = Span { start, end };
        let name = name.unescape().ok_or_else(|| ParseError::User { error: UserError::invalid_escape_sequence(span)})?;
        Ok(Ident { name: name.into(), span })
    }
}

SubstitutedParameterReference: Ident<'a> = {
    <start: @L> <name: "substituted parameter reference"> <end: @R> =>? {
        let span = Span { start, end };
        let name = name.unescape().ok_or_else(|| ParseError::User { error: UserError::invalid_escape_sequence(span)})?;
        Ok(Ident { name: name.into(), span })
    }
}

NodeSynonym = { "NODE", "VERTEX" }

EdgesSynonym = { "EDGES", "RELATIONSHIPS" }

EdgeSynonym = { "EDGE", "RELATIONSHIP" }

// Helper rules.
ListHelper<Item, Sep>: Vec<Item> = {
    <first: Item> <remaining: (Sep <Item>)*> => {
        let mut items = Vec::with_capacity(1 + remaining.len());
        items.push(first);
        items.extend(remaining);
        items
    }
}

FunctionHelper1<F, A1> = F "(" <A1> ")";

FunctionHelper2<F, A1, A2> = F "(" <A1> "," <A2> ")";